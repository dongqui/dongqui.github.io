---
layout: post
title: "copl.it"
tags: [project]
---
이 글은 어쩌면 제가 남긴 프로젝트를 진행하게 될지도 모를, 다음 HIR분들이 피해야할 길을 알려주는 가이드가 될지도 모르겠습니다.

coplit은 코드스테이츠 수강생들의 코드를 자동으로 테스트해주는 웹 서비스입니다. 이 프로젝트의 근본이 된, 제가 개발하면서 포기하지 않았던 두 가지가 있습니다.

1. 어떤 코드가 날라와도 우리의 시스템에 영향이 가지 않도록, 그리고 유저 각자의 테스트를 위한 고유의 환경 제공하기 위해 DOCKER를 도입 했습니다.

2. 주된 어드민이 될, 개발자를 위한 환경을 조성하고 싶었습니다. 개발자가 수강생들을 위한 테스트케이스를 만들면서 스스로 Run해보고 테스트할 수 있는 가장 편한 환경이 어디일까요? 자기 로컬 환경입니다. 로컬에서의 작업 이후에 단순히 Git commit, push로 coplit web에서 사용되는 data까지 업데이트 할 수 있는 환경을 조성하고 싶었습니다. 더욱더 격렬하게 편하고 싶은게 개발자니까요.

이 두 가지 사항은 재앙의 씨앗이 되기도 합니다.

처음엔 Docker image를 각각의 코스에 맞게 여러개를 구성하려고 했습니다. 예를 들면, 프리코스의 8주 동안 진행되는 오프토이 문제와 테스트케이스들, IAT시험을 위한 문제와 테스트케이스 등 각각의 코스에 맞는 테스트케이스를 지닌 Docker image들을 다수 구성하려고 했습니다. 이렇게 생각했던 이유는, Github와 Docker image 저장소인 DockerHub가 꽤나 괜찮은 서비스를 제공하고 있었기 때문이었습니다. Dockerhub에서 특정 github 레파지토리를 보다가 푸쉬가 들어오면, 그 레파지토리에 담긴 Dockerfile을 이용해 자동으로 도커 이미지를 빌드 할 수 있습니다. 게다가 우리쪽 서버에 post를 보내는 훅을 설정 할 수 있기 때문에 자동 pull도 가능합니다. 어차피 데이터들을 깃을 이용해 파일로 관리할거면 도커 이미지들도 붙여서 함께 관리하면 될거라고 생각했던거죠.

{% include image.html path="postimages/coplit.001.jpeg" path-detail="postimages/coplit.001.jpeg" alt="" %}

하지만 이 과정엔 치명적인 단점이 있었습니다. Dockerhub 쪽에서 제공하는 webhook은  성공했을 때 밖에 걸지를 못합니다. 실패 했을 때는 이메일이라도 보내준다고 하지만 중간에 있는 queued 나 buid 상태에서 멈춘다면 우리가 직접 확인하지 않는 이상 우리 이미지가 어떻게 되고 있는지 알 길이 없습니다.

그래서 저는 온전한 트랜잭션을 보장하기 위해 git hook을 이용해서 직접 git commit과 push전에 hook을 달기로 합니다. 아래는 commit 전 hook입니다. 도커이미지 빌드에 이상이 없을 때만 커밋 할 수 있도록 설정했습니다.
```bash
imageName="dongqui/$(basename -s .git `git config --get remote.origin.url`)"
imageDir="../../"
cd $imageDir
[-z $(docker images -q imageName)] || docker rmi -f imageName
docker image build -t dongqui/$imageName
isBuilt=$?
if [ isBuilt -ne 0 ] {
exit 1
}
fi
```

이 삽질 와중에도 Git hook이라는 존재를 알았다는 것 자체에 위안을 얻을 정도로, Git hook은 소중한 아이라고 생각됩니다. 앞으로 쓰임새가 정말 많을 거라고 생각해요. 배민에서는 깃 커밋을 하는 순간 자동으로 이미지를 압축해주는 스크립트를 예시로 보여주기도 했습니다.
[http://woowabros.github.io/tools/2017/07/12/git_hook.html](http://woowabros.github.io/tools/2017/07/12/git_hook.html) <br>git hook에 대한 정보도 볼 겸 참고하시면 좋을 거 같아요.

하지만 이대로라면 관리 할 때 헬게이트가 열릴 것이라고 오랜 시간이 되지 않아 깨닫게 되었습니다. 각각의 코스로 분기해서 관리를 한다면, 깃헙 레파지토리와 도커허브 레파지토리가 다수로 늘어날텐데, 이런 훅을 거는 번거로운 설정들을 일일이 하고 있을 수는 없지요 ㅠㅠ 게다가 데이터 관계를 구성하기 위해 데이터베이스와 레파지토리에 있는 File 간의 sync를 생각하면, 여러 레파지토리가 존재 할 경우 관리가 거의 불가능.... 단순한 사실인데 왜 미쳐 생각을 못했는지 의문입니다 ㅠ_ㅠ 삽질 전 까지는 자기가 망했는지 모르는 건 주주주니어 개발자의 종특인가봅니다. (설마 나만..?)
{% include image.html path="postimages/coplit.002.jpeg" path-detail="postimages/coplit.002.jpeg" alt="" %}

이때부터 파일로 관리하는 데이터와, 도커이미지를 분리해서 생각하기 시작했습니다. 도커 이미지는 최소한의 기능으로 구성하기로 합니다. 예를 들어, 단순 자바스크립트 파일만 테스트한다면, 테스트파일을 이미지에 포함하지 않고 node, mocha정도만 이미지로 구성합니다. 그리고 여러 개의 코스가 하나의 이미지를 공유하도록 하고, 도커이미지 관리를 최소한으로 줄이는 방법으로 대체합니다.

{% include image.html path="postimages/coplit.003.jpeg" path-detail="postimages/coplit.003.jpeg" alt="" %}

그리고 데이터베이스에 업데이트하기 쉽도록, 관리하는 파일의 폴더 구조를 데이터베이스에 형성된 관계에 맞춰 구성합니다.
{% include image.html path="postimages/coplit.004.jpeg" path-detail="postimages/coplit.004.jpeg" alt="" %}

그렇게 폴더 구조를 구성하고, 깃헙에 걸어 놓은 훅으로 부터 아래와 같은 페이로드를 받았을 때, 어떤 데이터가 변경 되었는지 분석해서 자동으로 데이터베이스에 반영하는 로직을 서버에 구현해놓았습니다.
{% include image.html path="postimages/coplit.002.jpeg" path-detail="postimages/coplit.006.jpeg" alt="" %}

또한 인간은 실수를 반복하는 동물임을 알기 때문에, 안정성을 위하여 데이터베이스와 맞춘 엄격한 폴더 스트럭쳐와 기본 파일명을 유지하기 위해 자동으로 폴더구조와 기본 파일들을 생성해주는 작은 프로그램도 만들었습니다.
{% include image.html path="postimages/coplit.002.jpeg" path-detail="postimages/coplit.007.jpeg" alt="" %}

그리고 AWS EBS를 파일 저장소로 사용했습니다. EBS는 간단히 말하면 EC2에서 로컬 처럼 사용할 수 있는 저장소입니다. EC2의 폴더를 마운트해서 사용하게 됩니다. 그만큼 속도도 빠른데다가 도커 컨테이너에서 볼륨으로 접근 할 수 있어서 coplit구조와 정말 잘 맞습니다! 다만 스케일링 할 때에 번거로움이 있을 거에요.

결과적으로는 아래와 같은 아키텍쳐가 완성되었습니다.
{% include image.html path="postimages/coplit.005.jpeg" path-detail="postimages/coplit.005.jpeg" alt="" %}


결론: 안정성을 위해 git hook이나 자동폴더생성 같은 장치들을 만들어 두었지만, 여전히 '혹시'하는 마음이 남아있습니다. 그리고 확장성에 대해서는 전혀 답을 찾지 못했습니다. 코플잇 확장이라는 이슈가 언제 생길지는 모르겠지만, 그 때가 오면 신경써야 할 부분이 꽤 많습니다. <br>서두에 나왔던 '재앙', '피해야 할 길'과 같은 단어들이 등장한 이유입니다. 앞으로 코플잇 프로젝트가 어떻게 진행 되든, 참고하실 수 있도록 로그 형식으로 문서를 남겨보았습니다.
더 자세한 설명이 필요한 부분들은 추합해서 다시 전달해드리겠습니다!

